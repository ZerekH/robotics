import time
import numpy as np
from mbot_bridge.api import MBot

def find_min_dist(ranges, thetas):
    """Finds the length and angle of the minimum ray in the scan.
    Make sure you ignore any rays with length 0! Those are invalid.
    Args:
        ranges (list): The length of each ray in the Lidar scan.
        thetas (list): The angle of each ray in the Lidar scan.
    Returns:
        tuple: The length and angle of the shortest ray in the Lidar scan.
    """
    ranges = np.array(ranges)
    thetas = np.array(thetas)
    
    # Filter out invalid readings (0 or negative)
    valid_idx = ranges > 0
    valid_ranges = ranges[valid_idx]
    valid_thetas = thetas[valid_idx]
    
    if len(valid_ranges) == 0:
        return None, None
    
    # Find min dist
    min_idx = np.argmin(valid_ranges)
    min_dist = valid_ranges[min_idx]
    min_angle = valid_thetas[min_idx]
    
    return min_dist, min_angle

robot = MBot()


TARGET_DISTANCE = 0.1     # Target distance to maintain (meters)
DISTANCE_TOLERANCE = 0  # Acceptable range around target
SPEED = 0.4                # How fast to move


try:
    while True:
        # Read the latest Lidar scan
        ranges, thetas = robot.read_lidar()
        
        # Get the distance and angle to the closest object
        dist_to_object, angle_to_object = find_min_dist(ranges, thetas)
        
        if dist_to_object is None:
            # check if no valid readings - stop
            robot.drive(0, 0, 0)
            print("No object detected")
            time.sleep(0.1)
            continue
        
        angle_error = np.abs(angle_to_object)

        if angle_error > np.radians(2):  # If angle > 2 degrees
            move_speed = SPEED
            status = "Moving toward"
        else:
            move_speed = 0
            status = "Stopped"
        
        # Convert polar (distance, angle) to Cartesian (vx, vy) 
        vx = move_speed * np.cos(angle_to_object)  # Forward/backward 
        vy = move_speed * np.sin(angle_to_object)  # Left/right 
        
        # Send drive command (vx, vy, wz) - no turning (wz=0)
        robot.drive(vx, vy, 0)
        
        # Print status
        angle_deg = np.degrees(angle_to_object)
        print(f"{status}: {dist_to_object:.2f}m at {angle_deg:+.1f}Â° | "
              f"vx: {vx:.2f}, vy: {vy:.2f}")
        
        time.sleep(0.1)

except KeyboardInterrupt:
    print("\nStopping robot...")
    robot.stop()
except Exception as e:
    print(f"\nError: {e}")
    robot.stop()
